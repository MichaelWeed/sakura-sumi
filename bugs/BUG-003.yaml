id: "BUG-003"
title: "Job tracking relies on in-process memory and local JSON file"
status: "wont-fix"
priority: "high"
severity: "major"
created_date: "2025-11-16"
updated_date: "2025-11-16"
resolved_date: null
reporter: "GPT-5 Codex"
assignee: "Unassigned"
environment:
  os: "macOS / Linux / Windows"
  browser: "All browsers"
  language_version: "Python 3.8+"
  dependencies: []
description: |
  Compression jobs are stored in a module-level dictionary and persisted to
  `build/jobs.json`. This approach is not safe for multi-instance deployments, loses
  jobs on process crash, and cannot scale beyond a single worker. High-profile integrators
  need durable storage (Redis, database) and horizontal scaling support.
steps_to_reproduce:
  - "Step 1: Start a compression job via POST /api/compress."
  - "Step 2: Restart the Flask process while the job is running."
  - "Step 3: Observe that job state is lost or corrupted, and concurrent workers disagree on progress."
expected_behavior: |
  Jobs should be persisted in a shared data store with locking so that restarts or
  multiple instances retain consistent state and progress.
actual_behavior: |
  Job metadata lives only in memory, with a best-effort JSON dump that is overwritten
  without locking and not shared across processes.
affected_files:
  - "src/web/app.py"
affected_functions:
  - "compress()"
  - "run_compression_job()"
  - "save_jobs()"
code_snippet: |
  jobs = {}
  job_counter = 0
  JOBS_FILE = Path(__file__).parent.parent.parent / 'build' / 'jobs.json'
  ...
  def save_jobs():
      with open(JOBS_FILE, 'w') as f:
          json.dump({'jobs': jobs, 'counter': job_counter}, f, indent=2)
error_message: |
  No explicit error, but job tracking resets when the process restarts or scales out.
root_cause: null
solution: null
fix_commit: null
fix_pr: null
test_coverage:
  has_unit_test: false
  has_integration_test: false
  regression_test_added: false
tags:
  - "scalability"
  - "reliability"
related_bugs: []
blocked_by: []
blocks: []
notes: |
  Durability is a prerequisite for enterprise adoption; consider Redis or database-backed queues.
  Deferred as enterprise integration item - requires shared storage infrastructure.
  See docs/developer/INTEGRATION_BACKLOG.md IB-03 for future implementation.
attachments:
  screenshots: []
  logs: []
  recordings: []
